syntax = "proto3";

package test_2;

message net_packet
{
	int32 system									= 1;	//系统号
	int32 cmd										= 2;	//协议号
	string data										= 3;	//二进制数据
}

//客户端消息协议
enum client_msg
{
	REQUEST_LOGIN									= 0;	//客户端请求登陆
	REQUSET_LUA_TABLE_DATA							= 1;	//请求二维表文件数据
	REQUSET_SAVE_TABLE_DATA							= 2;	//请求保存二维表数据
	REQUSET_SHELL_OPTIONS							= 3;	//客户端请求执行shell指令
	REQUEST_SAVE_TABLE_INFO							= 4;	//客户端请求保存二维表的外围信息
}

//服务器消息协议
enum server_msg
{
	SEND_FILE_TREE_INFO								= 0;	//推送当前左边文件树的数据
	SEND_SERVER_TIME								= 1;	//推送当前服务器时间
	SEND_LUA_TABLE_DATA								= 2;	//推送单个二维表文件数据
	SEND_SHELL_CONFIG								= 3;	//推送可执行的shell指令
	SEND_OPTION_SHELL_PRINT							= 4;	//推送执行shell的打印
}

//客户端请求登陆
message client_login_request
{
	
}

//推送左边文件树的数据
message server_send_file_tree_notify
{
	repeated string lua_file_names						= 1;	//一维表的文件名字列表
	repeated string lua_table_file_names				= 2;	//二维表的文件名字列表
	repeated string group_names							= 3;	//组合的名字列表
}

// 推送可执行的shell指令
message server_send_shell_config_notify
{
	repeated string shell_ops							= 1;	//shell指令列表
}

//客户端请求二维表文件数据
message client_lua_table_data_quest
{
	string file_name								= 1;	//文件名字
}

//客户端请求执行shell指令
message client_shell_option_quest
{
	string option									= 1;	//指令名字
}

//推送当前服务器时间
message server_send_current_time_notify
{
	int64 time_stamp 								= 1;	//当前服务器时间
	string time_zone 								= 2;	//时区
}

enum DATA_TYPE
{
	L_NUMBER 										= 0;	//数字类型
	L_STRING 										= 1;	//字符串类型
	L_BOOL 											= 2;	//bool类型
	L_TABLE_STRING 									= 3;	//字符串类型的table {a}
	L_FUNCTION 										= 4;	//字符串类型的function
}

message pair_value
{
	string key									= 1;	//键值
	string value								= 2;	//数值
}

message field_type_pair
{
	string key									= 1;	//字段
	int32 lua_type								= 2;	//数据的类型
}

//一行的数据
message row_data
{
	string key 								= 1;	//当前行的key
	repeated pair_value pair 				= 2;	//列数据列表
}

//levels :
//如果为空的话，证明这个squence代表的是最外层的字段顺序。
//如果levels为{[n]},则代表的是第n个字段为table的表的顺序
//如果levels为{[n],[m]},则代表的是第n个字段为table的表的第m个字段为table的表的顺序(就证明这个表就是多层结构了)
message field_squence
{
	repeated int32 levels						= 1;	//深度队列（如果为空，就是最外层的字段顺序）
	repeated string fields						= 2;	//字段顺序
}

//一张表的数据(仅仅只是二维程度的展开，如果有多维，则更深维度的表直接转换成string类型的数据)
message table_data
{
	string               		 table_name 			= 1;	//表名
	int32			     		 row_count 				= 2;	//多少行
	int32	             		 column_count 			= 3;	//多少列

	repeated string       		 filed_names 			= 4;	//字段名（直接从lua配置表读取到的字段顺序）
	repeated field_type_pair     filed_types 			= 5;	//字段的类型(跟字段名一一对应, 规定lua的二维表每行配置字段名对应的字段的类型是一致的)
	repeated row_data    		 row_lists 				= 6;	//行数据列表

	//下面这部分有可能是没有的，一些由client手动配置的信息（字段顺序，字段标注，活动的字段组合）
	repeated field_squence 		 filed_sequences 		= 7;	//字段名展示的顺序(因为lua里面的key-value对象解析出来不是有序的，所以需要人为定义一个展示顺序，这个顺序是由client手动调整的，然后记录在中间配置文件中)
}

//一张二维表的其它信息(对应的是server里面的LuaTableInfoContainer类读取的lua文件结构)
message table_info
{
	string  table_name 							= 1;	//表名
	repeated field_squence filed_sequences 		= 2;	//字段名展示的顺序(因为lua里面的key-value对象解析出来不是有序的，所以需要人为定义一个展示顺序)
}

//客户端请求保存二维表数据
message client_save_table_data_request
{
	string  table_name 							= 1;	//表名
	repeated row_data   row_lists 				= 2;	//行数据列表	
}

//服务器返回推送执行shell的打印
message send_shell_option_print_notify
{
	string  	line  							= 1;	//打印行数据
	int32  		flag  							= 2; 	//是否结束(0: 未结束 1:结束)
}

//客户端请求保存二维表的外围信息
message client_save_table_info_request
{
	string   					 table_name 				= 1;	//表名
	repeated field_squence 		 filed_sequences 			= 2;	//二维表的顺序
}

//服务器推送当前服务器时间
message send_server_current_time_nofity
{
	int64		time 							= 1;	//当前服务器时间戳
}