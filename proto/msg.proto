syntax = "proto3";

package test_2;

message net_packet
{
	int32 system									= 1;	//系统号
	int32 cmd										= 2;	//协议号
	string data										= 3;	//二进制数据
}

enum DATA_TYPE
{
	L_NUMBER 										= 0;	//数字类型
	L_STRING 										= 1;	//字符串类型
	L_BOOL 											= 2;	//bool类型
	L_TABLE_STRING 									= 3;	//字符串类型的table {a}
	L_FUNCTION 										= 4;	//字符串类型的function
}

message pair_value
{
	string key									= 1;	//键值
	string value								= 2;	//数值
}

//一行的数据
message row_data
{
	string key 							= 1;	//当前行的key
	repeated pair_value pair 				= 2;	//列数据列表
}

//levels :
//如果为空的话，证明这个squence代表的是最外层的字段顺序。
//如果levels为{[n]},则代表的是第n个字段为table的表的顺序
//如果levels为{[n],[n]},则代表的是第n个字段为table的表的第m个字段为table的表的顺序(就证明这个表就是多层结构了)
message field_squence
{
	repeated int32 levels						= 1;	//深度队列（如果为空，就是最外层的字段顺序）
	repeated string field						= 2;	//字段顺序
	repeated string filed_types 				= 3;	//字段的类型
}

//一张表的数据(仅仅只是二维程度的展开，如果有多维，则更深维度的表直接转换成string类型的数据)
message table_info
{
	string  table_name 							= 1;	//表名
	int32	row_count 							= 2;	//多少行
	int32	column_count 						= 3;	//多少列
	repeated string filed_names 				= 4;	//字段名
	repeated string filed_types 				= 5;	//字段的类型(跟字段名一一对应)
	repeated field_squence filed_sequences 		= 6;	//字段名展示的顺序(因为lua里面的key-value对象解析出来不是有序的，所以需要人为定义一个展示顺序)
	repeated row_data row_lists 				= 7;	//行数据列表
}