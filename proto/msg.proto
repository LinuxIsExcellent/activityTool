syntax = "proto3";

package test_2;

message usr_login 
{
    string usrname = 1;
    string usrpasswd = 2;
}

message usr_info 
{
    int32 classrome = 1;
    string studentID = 2;
}

message student 
{
    int32 STAMP = 1;
    usr_login usrLogin = 2;
    usr_info usrInfo = 3;
    repeated int32 array = 4;
}

enum DATA_TYPE
{
	L_NUMBER 										= 0;	//数字类型
	L_STRING 										= 1;	//字符串类型
	L_BOOL 											= 2;	//bool类型
	L_TABLE_STRING 									= 3;	//字符串类型的table {a}
	L_FUNCTION 										= 4;	//字符串类型的function
}

//一行的数据
message row_data
{
	int32 column_count							= 1;	//多少列
	repeated string value_datas 				= 2;	//每个单元格的数据
}

//levels :
//如果为空的话，证明这个squence代表的是最外层的字段顺序。
//如果levels为{[n]},则代表的是第n个字段为table的表的顺序
//如果levels为{[n],[n]},则代表的是第n个字段为table的表的第m个字段为table的表的顺序(就证明这个表就是多层结构了)
message field_squence
{
	repeated int32 levels						= 1;	//深度队列（如果为空，就是最外层的字段顺序）
	repeated string field						= 2;	//字段顺序
}

//一张表的数据(仅仅只是二维程度的展开，如果有多维，则更深维度的表直接转换成string类型的数据)
message table_info
{
	string  table_name 							= 1;	//表名
	int32	row_count 							= 2;	//多少行
	int32	column_count 						= 3;	//多少列
	repeated string filed_names 				= 4;	//字段名
	repeated string filed_types 				= 5;	//字段的类型(跟字段名一一对应)
	repeated field_squence filed_sequences 		= 6;	//字段名展示的顺序(因为lua里面的key-value对象解析出来不是有序的，所以需要人为定义一个展示顺序)
	repeated row_data row_lists 				= 7;	//行数据列表
}